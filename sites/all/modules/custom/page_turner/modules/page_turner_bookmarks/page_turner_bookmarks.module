<?php
/**
 * @file
 *
 * Allow book marking of Page Turner pages
 *
 * Mike Widner <mikewidner@stanford.edu>
 *
 **/

define("PAGE_TURNER_BOOKMARK_FLAG", 'page_turner_bookmark'); // for consistency

/**
 * Implements hook_menu().
 */
function page_turner_bookmarks_menu() {
  $items = array();

  $items['admin/user-interface/page-turner/bookmark/add'] = array(
    'page callback' => 'page_turner_bookmarks_add',
    'access arguments' => 'flag page_turner_bookmark',
    'type' => MENU_CALLBACK,
    );
  $items['admin/user-interface/page-turner/bookmark/remove'] = array(
    'page callback' => 'page_turner_bookmarks_remove',
    'access arguments' => 'unflag page_turner_bookmark',
    'type' => MENU_CALLBACK,
    );
  return $items;
}

/*
 * Return bookmark page ranges for current node
 */
function page_turner_bookmarks_get_pages_marked($node) {
	global $user;
	$pages = array();
	$flag = flag_get_user_flags('node', $node->nid);
	if (isset($flag[PAGE_TURNER_BOOKMARK_FLAG])) {
		$flagging_wrapper = entity_metadata_wrapper('flagging', $flag[PAGE_TURNER_BOOKMARK_FLAG]->flagging_id);
		foreach ($flagging_wrapper->field_page_start->getIterator() as $delta => $value_wrapper) {
			$pages[$delta]['start'] = $value_wrapper->value();
		}
		foreach ($flagging_wrapper->field_page_end->getIterator() as $delta => $value_wrapper) {
			$pages[$delta]['end'] = $value_wrapper->value();
		}
	}
	return $pages;
}

/**
 * Parse _POST, Return array of page range and node context
 */
function page_turner_bookmarks_parse_query() {
	return array(
		$_POST['pages'],
		menu_get_object($type = 'node', $position = 1, drupal_lookup_path('source', $_POST['path']))
	);
}


/**
 * Return true if given page range has been bookmarked
 */
function page_turner_bookmarks_pages_marked($wrapper, $start, $end, &$delta = NULL) {
	$matches = array();
	foreach ($wrapper->field_page_start->getIterator() as $delta => $value_wrapper) {
		$matches[$delta] = 0;
		if ($start == $value_wrapper->value()) {
			++$matches[$delta];
		}
	}
	foreach ($wrapper->field_page_end->getIterator() as $delta => $value_wrapper) {
		if ($end == $value_wrapper->value()) {
			++$matches[$delta];
		}
	}
	foreach ($matches as $delta => $count) {
		// NB: Updates by-reference $delta in passing
		if ($count == 2) {
			return TRUE;
		}
	}
	$delta = NULL;
	return FALSE;
}
/**
 * Menu callback
 *
 * Creates a new bookmark for the selected page(s)
 **/
function page_turner_bookmarks_add() {
	list($pages, $node) = page_turner_bookmarks_parse_query();
	$bookmark_flag = flag_get_flag(PAGE_TURNER_BOOKMARK_FLAG);
	$flag = flag_get_user_flags('node', $node->nid);

	// TODO: Add exception handling, return success/failure as JSON
	// try { } catch (EntityMetadataWrapperException $exc) {
	if (isset($flag[PAGE_TURNER_BOOKMARK_FLAG])) {
		$flagging_wrapper = entity_metadata_wrapper('flagging', $flag[PAGE_TURNER_BOOKMARK_FLAG]->flagging_id);
	} else {
		$values = array(
			'flag_name' => PAGE_TURNER_BOOKMARK_FLAG,
			'fid' => $bookmark_flag->fid,
			'entity_type' => 'node',
			'entity_id' => $node->nid,
		);
		$flagging = entity_create('flagging', $values);
		$flagging_wrapper = entity_metadata_wrapper('flagging', $flagging);
	}

	if (!page_turner_bookmarks_pages_marked($flagging_wrapper, $pages['start'], $pages['end'])) {
		// Avoid duplicate bookmarks
		$flagging_wrapper->field_page_start[] = $pages['start'];
		$flagging_wrapper->field_page_end[] = $pages['end'];

		if (!isset($flagging)) {
			// Update an existing bookmark flagging, but prevent duplicates
			$flagging_wrapper->save();
		} else {
			// Save a new bookmark flag
			$bookmark_flag->flag('flag', $node->nid, NULL, FALSE, $flagging);
		}
	}
}

/**
 * Menu callback
 *
 * Removes existing bookmark for the selected page(s)
 **/
function page_turner_bookmarks_remove() {
	list($pages, $node) = page_turner_bookmarks_parse_query();
	$flag = flag_get_user_flags('node', $node->nid);
	if (isset($flag[PAGE_TURNER_BOOKMARK_FLAG])) {
		$flagging_wrapper = entity_metadata_wrapper('flagging', $flag[PAGE_TURNER_BOOKMARK_FLAG]->flagging_id);
		$delta = NULL;
		if (page_turner_bookmarks_pages_marked($flagging_wrapper, $pages['start'], $pages['end'], $delta)) {
			// Match found, delete it
			$flagging_wrapper->field_page_start[$delta] = NULL;
			$flagging_wrapper->field_page_end[$delta] = NULL;
			$flagging_wrapper->save();

			if ($flagging_wrapper->field_page_start->count() == 0) {
				// Bookmark is now empty, unflag the node
				$bookmark_flag = flag_get_flag(PAGE_TURNER_BOOKMARK_FLAG);
				$bookmark_flag->flag('unflag', $node->nid);
			}
			drupal_json_output('TRUE');
		}
	}
	drupal_json_output('FALSE');
	drupal_exit();
}

/**
 * Implements hook_node_view()
 */
function page_turner_bookmarks_node_view($node, $view_mode, $langcode) {
	$bookmarks = page_turner_bookmarks_get_pages_marked($node);
	drupal_add_js(array('page_turner_bookmarks' => $bookmarks), 'setting');
	drupal_add_js(drupal_get_path('module', 'page_turner_bookmarks') . '/js/page_turner_bookmarks.js', array('group' => 'page_turner', 'weight' => 10));
}